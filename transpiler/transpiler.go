package transpiler

import (
	"fmt"
	"io"
	"strings"

	"github.com/alecthomas/template"
	yaml "gopkg.in/yaml.v2"
)

const loaderTplText = `// Code generated by goautocfg.
// source: {{ .Source }}
// DO NOT EDIT!

package {{ .Package }}

import (
	"fmt"
	"github.com/spf13/viper"
)

type AutoCfg struct {
{{range $item := .Items}}
	_{{$item.Key}} {{$item.Type}}
{{end}}
}

var cfg *AutoCfg

func init() {
	cfg = New()
}

func New() *AutoCfg {
	a := new(AutoCfg)
	return a
}

{{range $item := .Items}}
func {{$item.KEY}}() {{$item.Type}} {
	return cfg._{{$item.Key}}
}
func (cfg *AutoCfg) {{$item.KEY}}() {{$item.Type}} {
	return cfg._{{$item.Key}}
}
{{end}}

func Load(name string, paths ...string) {
	cfg.Load(name, paths...)
}
func (cfg *AutoCfg) Load(name string, paths ...string) {
	v := viper.New()
	v.SetConfigName(name)
	for _, path := range paths {
		v.AddConfigPath(path)
	}
	err := v.ReadInConfig()
	if err != nil {
		panic(fmt.Errorf("Fatal error config file: %s \n", err))
	}
{{range $item := .Items}}
	cfg._{{$item.Key}} = v.{{$item.Function}}("{{$item.KEY}}")
{{end}}
}
`

type loader struct {
	Items           []item
	Source, Package string
}
type item struct {
	KEY, Key, Type, Function string
}

type schema map[string]string

func Transpile(sourceFile string, sourceContent []byte, targetPackage string, targetWriter io.Writer) error {
	schemaENV := make(schema)
	if err := yaml.Unmarshal(sourceContent, &schemaENV); err != nil {
		return err
	}

	loaderTpl, err := template.New("setup").Parse(loaderTplText)
	if err != nil {
		return err
	}

	items, err := getTplItems(schemaENV)
	if err != nil {
		return err
	}

	err = loaderTpl.Execute(targetWriter, &loader{
		Items:   items,
		Source:  sourceFile,
		Package: targetPackage,
	})
	if err != nil {
		return err
	}
	return nil
}

func getTplItems(schemaENV schema) ([]item, error) {
	items := make([]item, 0, len(schemaENV))
	for envKey, envType := range schemaENV {
		var i item
		i.KEY = strings.ToUpper(envKey)
		i.Key = strings.ToLower(envKey)
		switch envType {
		case "string":
			i.Type, i.Function = "string", "GetString"
		case "integer":
			i.Type, i.Function = "int", "GetInt"
		case "bool":
			i.Type, i.Function = "bool", "GetBool"
		case "float":
			i.Type, i.Function = "float64", "GetFloat64"
		case "strings":
			i.Type, i.Function = "[]string", "GetStringSlice"
		default:
			return nil, fmt.Errorf("parsing error: Invalid type %s. "+
				"Valid types: string integer bool float strings", envType)
		}
		items = append(items, i)
	}
	return items, nil
}
