package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"gopkg.in/alecthomas/kingpin.v2"
	"gopkg.in/yaml.v2"
	"io"
	"os"
	"text/template"
)

const setupFunctionTpl = `// Code generated by goautocfg.
// source: {{ .File }}
// DO NOT EDIT!

package {{ .Package }}

import (
	"fmt"
	"github.com/spf13/viper"
)

func ReadInCfg(name string, paths ...string){
	viper.SetConfigName(name)
	for _, path := range paths {
		viper.AddConfigPath(path)
	}
	err := viper.ReadInConfig()
	if err != nil {
		panic(fmt.Errorf("Fatal error config file: %s \n", err))
	}
}
`

type getter struct{ KEY, VAL_TYPE, FUN_TYPE string }

const getFunctionTpl = `func Get{{ .KEY }}() {{ .VAL_TYPE }} {
	return viper.{{ .FUN_TYPE }}("{{ .KEY }}")
}
`

var (
	parse               = kingpin.Command("parse", "Generate go config").Default()
	inputSchemaFilepath = parse.Arg("schema-file", "Schema filepath").Required().ExistingFile()
	packageName         = parse.Arg("package-name", "Set package name").Required().String()
	outputDirPath       = parse.Arg("output-dir",
		"Output directory path, If not mentioned, written to standard output").ExistingDir()
)

func main() {
	switch kingpin.Parse() {
	case "parse":
		kingpin.FatalIfError(generate(*inputSchemaFilepath, *outputDirPath), "Config file generation failed")
	}
}

func getSchema(filename string) (map[string]string, error) {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	schemaENV := make(map[string]string)
	if err := yaml.Unmarshal(content, &schemaENV); err != nil {
		return nil, err
	}
	return schemaENV, nil
}

func getOutputWriter(outputDirPath string) (io.Writer, error) {
	if outputDirPath == "" {
		return os.Stdout, nil
	}
	file, err := os.Create(outputDirPath + "/config.auto.go")
	if err != nil {
		return nil, err
	}
	return file, nil
}

func generate(filename string, outputDirPath string) error {
	schemaENV, err := getSchema(filename)
	if err != nil {
		return err
	}

	outputWriter, err := getOutputWriter(outputDirPath)
	if err != nil {
		return err
	}

	setupTpl, err := template.New("setup").Parse(setupFunctionTpl)
	if err != nil {
		return err
	}

	getTpl, err := template.New("func").Parse(getFunctionTpl)
	if err != nil {
		return err
	}

	setupTpl.Execute(outputWriter, struct{ File, Package string }{filename, *packageName})
	for envKey, envType := range schemaENV {
		var gttr getter
		switch envType {
		case "string":
			gttr = getter{envKey, "string", "GetString"}
		case "integer":
			gttr = getter{envKey, "int", "GetInt"}
		case "bool":
			gttr = getter{envKey, "bool", "GetBool"}
		case "float":
			gttr = getter{envKey, "float64", "GetFloat64"}
		case "strings":
			gttr = getter{envKey, "[]string", "GetStringSlice"}
		default:
			return errors.New(fmt.Sprintf("parsing error: Invalid type %s. Valid types: string integer bool float strings",
				envType))
		}
		err := getTpl.Execute(outputWriter, gttr)
		if err != nil {
			return err
		}
	}
	return nil
}
