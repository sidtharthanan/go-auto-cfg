package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"text/template"

	_ "github.com/spf13/viper"
	"gopkg.in/alecthomas/kingpin.v2"
	"gopkg.in/yaml.v2"
)

const loaderTplText = `// Code generated by goautocfg.
// source: {{ .Source }}
// DO NOT EDIT!

package {{ .Package }}

import (
	"fmt"
	"github.com/spf13/viper"
)

type AutoCfg struct {
{{range $item := .Items}}
	_{{$item.Key}} {{$item.Type}}
{{end}}
}

var cfg *AutoCfg

func init() {
	cfg = New()
}

func New() *AutoCfg {
	a := new(AutoCfg)
	return a
}

{{range $item := .Items}}
func {{$item.KEY}}() {{$item.Type}} {
	return cfg._{{$item.Key}}
}
func (cfg *AutoCfg) {{$item.KEY}}() {{$item.Type}} {
	return cfg._{{$item.Key}}
}
{{end}}

func Load(name string, paths ...string) {
	cfg.Load(name, paths...)
}
func (cfg *AutoCfg) Load(name string, paths ...string) {
	v := viper.New()
	v.SetConfigName(name)
	for _, path := range paths {
		v.AddConfigPath(path)
	}
	err := v.ReadInConfig()
	if err != nil {
		panic(fmt.Errorf("Fatal error config file: %s \n", err))
	}
{{range $item := .Items}}
	cfg._{{$item.Key}} = v.{{$item.Function}}("{{$item.KEY}}")
{{end}}
}
`

type loader struct {
	Items           []item
	Source, Package string
}
type item struct {
	KEY, Key, Type, Function string
}
type schema map[string]string

var (
	inputSchemaFilepath = kingpin.Arg("schema-file", "Schema filepath.").Required().ExistingFile()
	packageName         = kingpin.Arg("package-name", "Set package name.").Required().String()
	outputDirPath       = kingpin.Arg("output-dir", "Output directory. "+
		"If not mentioned, generated file is written to stdout.").ExistingDir()
)

func main() {
	kingpin.Parse()
	kingpin.FatalIfError(generate(*inputSchemaFilepath, *outputDirPath), "AutoCfg generation failed")
}

func getSchema(filename string) (schema, error) {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	schemaENV := make(schema)
	if err := yaml.Unmarshal(content, &schemaENV); err != nil {
		return nil, err
	}
	return schemaENV, nil
}

func getOutputWriter(outputDirPath string) (io.Writer, error) {
	if outputDirPath == "" {
		return os.Stdout, nil
	}
	file, err := os.Create(outputDirPath + "/config.auto.go")
	if err != nil {
		return nil, err
	}
	return file, nil
}

func getTplItems(schemaENV schema) ([]item, error) {
	items := make([]item, 0, len(schemaENV))
	for envKey, envType := range schemaENV {
		var i item
		i.KEY = strings.ToUpper(envKey)
		i.Key = strings.ToLower(envKey)
		switch envType {
		case "string":
			i.Type = "string"
			i.Function = "GetString"
		case "integer":
			i.Type = "int"
			i.Function = "GetInt"
		case "bool":
			i.Type = "bool"
			i.Function = "GetBool"
		case "float":
			i.Type = "float64"
			i.Function = "GetFloat64"
		case "strings":
			i.Type = "[]string"
			i.Function = "GetStringSlice"
		default:
			return nil, fmt.Errorf("parsing error: Invalid type %s. "+
				"Valid types: string integer bool float strings", envType)
		}
		items = append(items, i)
	}
	return items, nil
}

func generate(filename string, outputDirPath string) error {
	schemaENV, err := getSchema(filename)
	if err != nil {
		return err
	}

	outputWriter, err := getOutputWriter(outputDirPath)
	if err != nil {
		return err
	}

	loaderTpl, err := template.New("setup").Parse(loaderTplText)
	if err != nil {
		return err
	}

	items, err := getTplItems(schemaENV)
	if err != nil {
		return err
	}

	err = loaderTpl.Execute(outputWriter, &loader{
		Items:   items,
		Source:  filename,
		Package: *packageName,
	})
	if err != nil {
		return err
	}
	return nil
}
