package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"text/template"

	"path/filepath"

	_ "github.com/spf13/viper"
	"gopkg.in/alecthomas/kingpin.v2"
	"gopkg.in/yaml.v2"
)

const loaderTplText = `// Code generated by goautocfg.
// source: {{ .Source }}
// DO NOT EDIT!

package {{ .Package }}

import (
	"fmt"
	"github.com/spf13/viper"
)

type AutoCfg struct {
{{range $item := .Items}}
	_{{$item.Key}} {{$item.Type}}
{{end}}
}

var cfg *AutoCfg

func init() {
	cfg = New()
}

func New() *AutoCfg {
	a := new(AutoCfg)
	return a
}

{{range $item := .Items}}
func {{$item.KEY}}() {{$item.Type}} {
	return cfg._{{$item.Key}}
}
func (cfg *AutoCfg) {{$item.KEY}}() {{$item.Type}} {
	return cfg._{{$item.Key}}
}
{{end}}

func Load(name string, paths ...string) {
	cfg.Load(name, paths...)
}
func (cfg *AutoCfg) Load(name string, paths ...string) {
	v := viper.New()
	v.SetConfigName(name)
	for _, path := range paths {
		v.AddConfigPath(path)
	}
	err := v.ReadInConfig()
	if err != nil {
		panic(fmt.Errorf("Fatal error config file: %s \n", err))
	}
{{range $item := .Items}}
	cfg._{{$item.Key}} = v.{{$item.Function}}("{{$item.KEY}}")
{{end}}
}
`

type loader struct {
	Items           []item
	Source, Package string
}
type item struct {
	KEY, Key, Type, Function string
}
type schema map[string]string

var (
	inputSchemaFilepath = kingpin.Arg("schema-file", "Definitions of the configs read from here.").Required().ExistingFile()
	outputFilePath      = kingpin.Arg("output-file", "Config loader go file is created here.").Required().String()
	packageName         = ""
)

func main() {
	kingpin.Parse()
	kingpin.FatalIfError(createPackage(*outputFilePath, &packageName), "AutoCfg generation failed")
	kingpin.FatalIfError(generate(*inputSchemaFilepath, *outputFilePath), "AutoCfg generation failed")
}

func getSchema(filename string) (schema, error) {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	schemaENV := make(schema)
	if err := yaml.Unmarshal(content, &schemaENV); err != nil {
		return nil, err
	}
	return schemaENV, nil
}

func createPackage(outputFilePath string, packageName *string) error {
	outputDirPath, filename := filepath.Split(outputFilePath)
	*packageName = filepath.Base(outputDirPath)
	if filename == "" {
		return fmt.Errorf("filename missing: %v", outputFilePath)
	}
	if *packageName == "." {
		outputDirPath, _ = filepath.Abs(outputDirPath)
		*packageName = filepath.Base(outputDirPath)
	}

	if _, err := os.Stat(outputDirPath); os.IsNotExist(err) {
		if err := os.MkdirAll(outputDirPath, 0755); err != nil {
			return fmt.Errorf("not able to create/reuse package '%v' at '%v'\n%v", *packageName, outputDirPath, err)
		}
	} else if err != nil {
		return fmt.Errorf("not able to create/reuse package '%v' at '%v'\n%v", *packageName, outputDirPath, err)
	}
	return nil
}

func getOutputWriter(outputFilePath string) (io.Writer, error) {
	file, err := os.Create(outputFilePath)
	if err != nil {
		return nil, err
	}
	return file, nil
}

func getTplItems(schemaENV schema) ([]item, error) {
	items := make([]item, 0, len(schemaENV))
	for envKey, envType := range schemaENV {
		var i item
		i.KEY = strings.ToUpper(envKey)
		i.Key = strings.ToLower(envKey)
		switch envType {
		case "string":
			i.Type, i.Function = "string", "GetString"
		case "integer":
			i.Type, i.Function = "int", "GetInt"
		case "bool":
			i.Type, i.Function = "bool", "GetBool"
		case "float":
			i.Type, i.Function = "float64", "GetFloat64"
		case "strings":
			i.Type, i.Function = "[]string", "GetStringSlice"
		default:
			return nil, fmt.Errorf("parsing error: Invalid type %s. "+
				"Valid types: string integer bool float strings", envType)
		}
		items = append(items, i)
	}
	return items, nil
}

func generate(filename string, outputFilePath string) error {
	schemaENV, err := getSchema(filename)
	if err != nil {
		return err
	}

	outputWriter, err := getOutputWriter(outputFilePath)
	if err != nil {
		return err
	}

	loaderTpl, err := template.New("setup").Parse(loaderTplText)
	if err != nil {
		return err
	}

	items, err := getTplItems(schemaENV)
	if err != nil {
		return err
	}

	err = loaderTpl.Execute(outputWriter, &loader{
		Items:   items,
		Source:  filename,
		Package: packageName,
	})
	if err != nil {
		return err
	}
	return nil
}
